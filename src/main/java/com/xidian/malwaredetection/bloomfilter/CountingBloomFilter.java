package com.xidian.malwaredetection.bloomfilter;

import java.util.Collection;
import java.util.List;
import java.util.stream.Collectors;

/**
 * 表示计数布隆过滤器，与普通布隆过滤器相反，也允许删除。
 */
public interface CountingBloomFilter<T> extends BloomFilter<T> {

    /**
     * @return 用于计数的位数
     */
    public default int getCountingBits() {
        return config().countingBits();
    }

    @Override
    public default boolean add(int[] hash){
        return addHashAndEstimateCount(hash) == 1;
    }

    @Override
    public default boolean add(byte[] element) {
        return addAndEstimateCount(element) == 1;
    }

    /**
     * 从计数布隆过滤器中删除对象。
     *
     * @param element 要删除的对象
     * @return {@code true} 如果删除后元素不存在
     */
    public default boolean remove(byte[] element) {
        return removeAndEstimateCount(element) <= 0;
    }

    /**
     * 从计数布隆过滤器中删除对象。
     *
     * @param element 要删除的对象
     * @return {@code true} 如果删除后元素不存在
     */
    public default boolean remove(T element) {
        return remove(toBytes(element));
    }


    /**
     * 从计数布隆过滤器中删除对象。
     *
     * @param elements 要删除的对象
     * @return 一个布尔值列表，指出每个元素是否被删除
     */
    public default List<Boolean> removeAll(Collection<T> elements) {
        return elements.stream().map(this::remove).collect(Collectors.toList());
    }

    /**
     * 使用Mininum Selection算法返回元素的估计计数（即，通过选择给定元素的最小计数器）。 这种估计是有偏见的，
     * 因为它不考虑过滤器有多满，但在实践中表现最佳。 基础理论基础是谱布隆过滤器，参见：
     * http：//theory.stanford.edu/~matias/papers/sbf_thesis.pdf
     *
     * @param element element to query
     * @return estimated count of the element
     */
    public long getEstimatedCount(T element);

    /**
     * 添加元素并在插入后返回其估计频率（即元素添加到滤波器的次数）。
     *
     * @param element element to add
     * @return 插入后元素的估计频率
     */
    public long addAndEstimateCount(byte[] element);

    public long addHashAndEstimateCount(int[] hash);

    /**
     * 添加元素并在插入后返回其估计频率（即元素添加到滤波器的次数）。
     *
     * @param element element to add
     * @return estimated frequency of the element after insertion
     */
    public default long addAndEstimateCount(T element) {
        return addAndEstimateCount(toBytes(element));
    }

    /**
     * 删除元素并在插入后返回其估计频率（即元素添加到滤波器的次数）。
     *
     * @param element element to remove
     * @return 估计删除后元素的频率
     */
    public long removeAndEstimateCount(byte[] element);

    /**
     * 删除元素并在插入后返回其估计频率（即元素添加到filter的次数）。
     *
     * @param element element to remove
     * @return estimated frequency of the element after deletion
     */
    public default long removeAndEstimateCount(T element) {
        return removeAndEstimateCount(toBytes(element));
    }

    /**
     * @return copy of the filter.
     */
    public CountingBloomFilter<T> clone();

}

