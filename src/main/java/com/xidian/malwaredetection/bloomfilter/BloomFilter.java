package com.xidian.malwaredetection.bloomfilter;

import java.io.Serializable;
import java.util.BitSet;
import java.util.Collection;
import java.util.List;
import java.util.stream.Collectors;

/**
 * 表示Bloom过滤器并提供散列的默认方法。
 */
public interface BloomFilter<T> extends Cloneable, Serializable {

    /**
     * 将传递的hash添加到过滤器
     * @param hash
     * @return
     */
    public boolean add(int[] hash);

    /**
     * 将传递的值添加到过滤器。
     *
     * @param element 要添加的值
     * @return {@code true} 如果过滤器中先前不存在该值。 注意，可能会出现误报，
     * 因此该值可能尚未出现在过滤器中，但它已经过滤到过滤器中已有的一组位。
     */
    public boolean add(byte[] element);

    /**
     * 将传递的值添加到过滤器。
     *
     * @param element value to add
     * @return {@code true} 如果过滤器中先前不存在该值。 注意，可能会出现误报，
     * 因此，该值可能尚未在过滤器中，但它已经过滤到过滤器中已有的一组位。
     */
    public default boolean add(T element) {
        return add(toBytes(element));
    }

    /**
     * 对元素集合执行批量添加操作。
     *
     * @param elements to add
     * @return 一个布尔值列表，指示每个元素，它是否先前存在于过滤器中
     */
    public default List<Boolean> addAll(Collection<T> elements) {
        return elements.stream().map(this::add).collect(Collectors.toList());
    }

    /**
     * 从过滤器中删除所有元素（即将所有位重置为零）。
     */
    public void clear();

    /**
     * 测试过滤器中是否存在元素（受指定的误报率影响）。
     *
     * @param element to test
     * @return {@code true} 如果元素被包含
     */
    public boolean contains(byte[] element);

    /**
     * 检测过滤器是包含hash
     * @param hash
     * @return
     */
    public boolean contains(int[] hash);

    /**
     * 测试过滤器中是否存在元素（受指定的误报率影响）。
     *
     * @param element to test
     * @return {@code true} 如果元素被包含
     */
    public default boolean contains(T element) {
        return contains(toBytes(element));
    }

    /**
     * 批量测试过滤器中存在的元素。
     *
     * @param elements 要测试的元素集合
     * @return 一个布尔值列表，指示每个元素是否存在于过滤器中
     */
    public default List<Boolean> contains(Collection<T> elements) {
        return elements.stream().map(this::contains).collect(Collectors.toList());
    }

    /**
     * 批量测试过滤器中存在的元素。
     *
     * @param elements a collection of elements to test
     * @return {@code true} 如果过滤器中存在所有元素
     */
    public default boolean containsAll(Collection<T> elements) {
        return elements.stream().allMatch(this::contains);
    }

    /**
     * 返回Bloom过滤器的基础位向量。
     *
     * @return Bloom过滤器的基础位向量。
     */
    public BitSet getBitSet();

    /**
     * 返回Bloom过滤器的配置/构建器。
     *
     * @return Bloom过滤器的配置/构建器。
     */
    public FilterBuilder config();

    /**
     * 构造Bloom过滤器的深层副本
     *
     * @return 克隆的Bloom过滤器
     */
    public BloomFilter<T> clone();

    /**
     * 返回布隆过滤器的大小，即底部位向量中的位置数（在文献中称为m）。
     *
     * @return 位向量大小
     */
    public default int getSize() {
        return config().size();
    }

    /**
     * 返回预期的元素数（在文献中称为n）
     *
     * @return 预期的元素数量
     */
    public default int getExpectedElements() {
        return config().expectedElements();
    }

    /**
     * 返回散列函数的数量（在文献中称为k）
     *
     * @return 哈希函数的数量
     */
    public default int getHashes() {
        return config().hashes();
    }

    /**
     *返回预期元素数量的预期误报概率。 这与过滤器中的实际元素数量无关。
     * 为此目的使用{@link #getFalsePositiveProbability（double）}。
     *
     * @return 静态预期误报概率
     */
    public default double getFalsePositiveProbability() {
        return config().falsePositiveProbability();
    }

    /**
     * 将元素转换为用于散列的字节数组表示形式。
     *
     * @param element 将元素转换为用于散列的字节数组表示形式。
     * @return 元素字节数组表示
     */
    public default byte[] toBytes(T element) {
        return element.toString().getBytes(FilterBuilder.defaultCharset());
    }

    /**
     * 检查两个Bloom过滤器是否兼容，即是否具有兼容参数（散列函数，大小等）
     *
     * @param bloomFilter the bloomfilter
     * @param other the other bloomfilter
     * @return <code>true</code> 如果这个bloomfilter与另一个相容
     *
     * @see #compatible(BloomFilter)
     */
    @Deprecated
    public default boolean compatible(BloomFilter<T> bloomFilter, BloomFilter<T> other) {
        return bloomFilter.compatible(other);
    }

    /**
     * 检查两个Bloom过滤器是否兼容，即是否具有兼容参数（散列函数，大小等）
     *
     * @param other the other bloomfilter
     * @return <code>true</code> 如果这个bloomfilter与另一个相容
     */
    public default boolean compatible(BloomFilter<T> other) {
        return config().isCompatibleTo(other.config());
    }

    /**
     * 通过删除其内容和元数据来销毁Bloom过滤器
     */
    public default void remove() {
        clear();
    }

    /**
     * 以字节数组形式返回input元素的k哈希值
     *
     * @param bytes input element
     * @return hash values
     */
    public default int[] hash(byte[] bytes) {
        return config().hashFunction().hash(bytes, config().size(), config().hashes());
    }

    /**
     * 调度哈希函数以获取字符串值
     *
     * @param value the value to be hashed
     * @return array with <i>hashes</i> integer hash positions in the range <i>[0,size)</i>
     */
    public default int[] hash(String value) {
        return hash(value.getBytes(FilterBuilder.defaultCharset()));
    }

    /**
     * 在两个兼容的bloom过滤器上执行union操作。 这是通过对其位向量的按位OR运算来实现的。 这种操作是无损的，即没有元素丢失，
     * 并且如果所有元素都直接插入一个布隆过滤器中，布隆过滤器就会产生相同的效果。
     *
     * @param other the other bloom filter
     * @return <tt>true</tt> 如果这个布隆过滤器可以通过与提供的布隆过滤器的并集成功更新
     */
    boolean union(BloomFilter<T> other);

    /**
     * 在两个兼容的bloom过滤器上执行交叉操作。 这是通过对其位向量的按位AND运算来实现的。 这些操作不会引入任何漏报，
     * 但确实会增加误报概率。 得到的布隆过滤器中的假阳性概率至多是组成布隆过滤器之一中的假阳性概率
     *
     * @param other the other bloom filter
     * @return <tt>true</tt> if this bloom filter could successfully be updated through the intersection with the
     * provided bloom filter
     */
    boolean intersect(BloomFilter<T> other);

    /**
     * Returns {@code true} 如果Bloom过滤器不包含任何元素
     *
     * @return {@code true} 如果Bloom过滤器不包含任何元素
     */
    boolean isEmpty();

    /**
     * 返回误报概率（近似值）: <br> <code>(1 - e^(-hashes * insertedElements / size)) ^ hashes</code>
     *
     * @param insertedElements 已插入Bloomfilter的元素数量
     * @return probability of a false positive after <i>expectedElements</i> {@link #add(byte[])} operations
     */
    public default double getFalsePositiveProbability(double insertedElements) {
        return FilterBuilder.optimalP(config().hashes(), config().size(), insertedElements);
    }

    /**
     * 使用估计过滤器中当前有多少元素，返回误报（近似）的概率
     *
     * @return 假阳性的概率
     */
    public default double getEstimatedFalsePositiveProbability() {
        return getFalsePositiveProbability(getEstimatedPopulation());
    }


    /**
     * 根据预期的插入元素数计算每个元素的位数
     * <i>expectedElements</i>.
     *
     * @param n 已插入Bloomfilter的元素数量
     * @return 每个元素的位数
     */
    public default double getBitsPerElement(int n) {
        return config().size() / (double) n;
    }

    /**
     * 返回位为零的概率。
     *
     * @param n The number of elements already inserted into the Bloomfilter
     * @return 在<i> expectedElements </ i> {@link #add（byte []）}操作之后某个位为零的概率
     */
    public default double getBitZeroProbability(int n) {
        return Math.pow(1 - (double) 1 / config().size(), config().hashes() * n);
    }

    /**
     * 估计Bloom过滤器的当前数量（请参阅：
     * http：//en.wikipedia.org/wiki/Bloom_filter#Approximating_the_number_of_items_in_a_Bloom_filter）
     *
     * @return 过滤器中元素的估计数量
     */
    public default Double getEstimatedPopulation() {
        return population(getBitSet(), config());
    }

    public static Double population(BitSet bitSet, FilterBuilder config) {
        int oneBits = bitSet.cardinality();
        return -config.size() / ((double) config.hashes()) * Math.log(1 - oneBits / ((double) config.size()));
    }

    /**
     * 打印Bloom过滤器：元数据和数据
     *
     * @return Bloom过滤器的字符串表示形式
     */
    public default String asString() {
        StringBuilder sb = new StringBuilder();
        sb.append("Bloom Filter Parameters: ");
        sb.append("size = " + config().size() + ", ");
        sb.append("hashes = " + config().hashes() + ", ");
        sb.append("Bits: " + getBitSet().toString());
        return sb.toString();
    }


}
